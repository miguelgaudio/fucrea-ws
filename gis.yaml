swagger: '2.0'

info:
  version: "1"
  title: fucrea
  description: |
    # como en https://developers.google.com/maps/documentation/javascript/3.24/reference#Data, el metodo addGeoJson
    # como en https://developers.google.com/maps/documentation/javascript/3.24/reference#Data, el metodo toGeoJson
    # como en https://developers.google.com/maps/documentation/javascript/3.exp/reference#Polygon

    # overlay es un objeto poligono https://developers.google.com/maps/documentation/javascript/3.24/reference#Polygon
    # function encode_paths(overlay){
    #   let g_paths = overlay.getPaths()
    #   return g_paths.getArray().map(function(ee){
    #     var polig = ee.getArray().map(function(ea){
    #       return [ea.lng(), ea.lat()];
    #     });
    #     if ((polig.length > 0) && ((polig[0][0] != polig[polig.length-1][0]) || (polig[0][1] != polig[polig.length-1][1]))) {
    #       polig.push(polig[0]);
    #     }
    #     return polig;
    #   });
    # }

    # function load_g_polygon(j_multi_paths){
    #   var g_muti_paths = [];
    #   for (let j_paths of j_multi_paths){
    #     var g_paths = [];
    #     for (let j_path of j_paths){
    #       var g_path = [];
    #       for (let j_coord of j_path) {
    #           g_path.push(new google.maps.LatLng(j_coord[1], j_coord[0]));
    #       }
    #       g_paths.push(g_path);
    #     }
    #     g_muti_paths.push(g_paths);
    #   }
    #   var poligons = [];
    #   for (let path of g_muti_paths){
    #     var pp = new google.maps.Polygon({
    #       paths: path,
    #       clickable: false,
    #       editable: false,
    #       draggable: false,
    #       fillColor: 'white',
    #       strokeColor: 'black',
    #       fillOpacity: 0.4,
    #       strokeOpacity: 1,
    #       strokeWeight: 0.5,
    #       zIndex: 1
    #     });
    #     poligons.push(pp);
    #   }
    #   //mzs.geocerca.g_polygon.setOptions({visible: true});
    #   return new MultiPolygon(poligons);
    # }

    # function decode_paths(j_paths){
    #   var g_paths = [];
    #   for (let j_path of j_paths){
    #     var g_path = [];
    #     for (let j_coord of j_path) {
    #       g_path.push(new google.maps.LatLng(j_coord[1], j_coord[0]));
    #     }
    #     g_paths.push(g_path);
    #   }
    #   return g_paths;
    # }

host: basic-auth-server.herokuapp.com
schemes:
  - https

paths:
  /gis/encode_kml/:
    get:
      description: |
        Se le pasa un archivo KML con un conjunto de particiones y retorna el Geojson correspondiente, tomando el nombre de cada placeholder como Id de cada particion (y feature collection).
        Se le envia una geojson y retorna el mismo como un archivo en KML, donde el Id de cada particion se transforma en el nombre de cada placeholder. Puede incluir cierta metadata en ExtraData.
        Debe ser compatible con los KML creados por google-earth (pero no compatible con todos los KML que google-earth puede levantar, en caso de problemas cargar este KML en google-earth y volver a exportarlo, como modo de normalizacion).
        Si varios placeholders del KML tienen igual nombre, estos se fundiran y se interpretaran como una sola cosa.
      consumes:
        - application/json
      produces:
        - application/vnd.google-earth.kml+xml
      parameters:
        -
          name: shapes
          in: body
          description: Shapes
          required: true
          schema:
            $ref: '#/definitions/GEOJsonFeatureCollection'
      responses:
        200:
          description: Usuarios obtenidos correctamente
          schema:
            type: object
            items:
              $ref: '#/definitions/User'
        400:
          description: Error del cliente
        500:
          description: Error del servidor

  /gis/decode_kml/:
    get:
      description: |
        Se le pasa un archivo KML con un conjunto de particiones y retorna el Geojson correspondiente, tomando el nombre de cada placeholder como Id de cada particion (y feature collection).
      consumes:
        - multipart/form-data
      produces:
        - application/json
      parameters:
        -
          name: kml_file
          in: formData
          description: The avatar of the user
          required: true
          type: file
      responses:
        200:
          description: 
          schema:
            type: file
        400:
          description: Error del cliente
        500:
          description: Error del servidor

  /gis/partition_selection/:
    get:
      description: |
        De modo similar a partition_creation, este WS crea y funde particiones.
        Funde todas las particiones CONTENIDAS (a diferencia de partition_creation) por el poligono de entrada "blade" en un nuevo multipoligono (geocerca) con el Id de la "figura activa" (active_sahpe_id).
        Retorna el conjunto de todas las particiones nuevas (incluso las particiones vacias de Id ya existentes como collecciones vacias).
        Opcionalmente esta operación se realiza sin provocar un resultado fuera de otra geocerca que marca los limites "Bound" (siempre se termina intersectando el resultado contra Bound).
        Puede modelarse la particion que no partenece a ninguna particion anterior (aka residual) asignandole un Id no usado con anterioridad, típicamente el Id = -1, de este modo también puede lograrse eliminar una particion asignando como figura activa a la de Id = -1
      consumes:
        - application/json
      produces:
        - application/json
      parameters:
        -
          name: active_shape_id
          in: body
          description: El Id de la figura a la cual se le agrega la particion
          required: true
          type: string
        -
          name: blade
          in: body
          description: Blade
          required: true
          schema:
            $ref: '#/definitions/PathsGeometry'
        -
          name: bound
          in: body
          description: Bound
          required: true
          schema:
            $ref: '#/definitions/PathsGeometry'
        -
          name: shapes
          in: body
          description: Shapes
          required: true
          schema:
            $ref: '#/definitions/GEOJsonFeatureCollection'
      responses:
        200:
          description: Conjunto de particiones luego de fundir, simplificar y normalizar las diferentes particiones de entrada segun el blade y la particion activa
          schema:
            type: object
            items:
              $ref: '#/definitions/GEOJsonFeatureCollection'
        400:
          description: Error del cliente (posiblemente en el formateo, ya que no hay otros errores semanticos posibles)
        500:
          description: Error del servidor

  /gis/partition_creation/:
    get:
      description: |
        De modo similar a partition_selection, este WS crea y funde particiones.
        Crea fundiendo y cortando una nueva particion definida por el poligono de entrada "blade" y el Id de la "figura activa" (active_sahpe_id). Roba superficie de cualquier otra particion con la que pudiera intersectarse
        Retorna el conjunto de todas las particiones nuevas (incluso las particiones vacias de Id ya existentes como collecciones vacias).
        Puede crear nuevas particiones si el Id de figura activa no se encontraba entre las particiones.
        Opcionalmente esta operación se realiza sin provocar un resultado fuera de otra geocerca que marca los limites "Bound" (siempre se termina intersectando el resultado contra Bound).
        Puede modelarse la particion que no partenece a ninguna particion anterior (aka residual) asignandole un Id no usado con anterioridad, típicamente el Id = -1, de este modo también puede lograrse eliminar una particion asignando como figura activa a la de Id = -1
      consumes:
        - application/json
      produces:
        - application/json
      parameters:
        -
          name: active_shape_id
          in: body
          description: El Id de la figura a la cual se le agrega la particion
          required: true
          type: string
        -
          name: blade
          in: body
          description: Blade
          required: true
          schema:
            $ref: '#/definitions/PathsGeometry'
        -
          name: bound
          in: body
          description: Bound
          required: true
          schema:
            $ref: '#/definitions/PathsGeometry'
        -
          name: shapes
          in: body
          description: Conjunto de multipoligonos (geocercas) que representan una posible particion de una region.
          required: true
          schema:
            $ref: '#/definitions/GEOJsonFeatureCollection'
      responses:
        200:
          description: Conjunto de particiones luego de fundir, simplificar y normalizar las diferentes particiones de entrada segun el blade y la particion activa
          schema:
            type: object
            items:
              $ref: '#/definitions/GEOJsonFeatureCollection'
        400:
          description: Error del cliente (posiblemente en el formateo, ya que no hay otros errores semanticos posibles)
        500:
          description: Error del servidor

definitions:
  PathsGeometry:
    # overlay es un objeto poligono https://developers.google.com/maps/documentation/javascript/3.24/reference#Polygon
    type: object

  GEOJsonFeatureCollection:
    # como en https://developers.google.com/maps/documentation/javascript/3.24/reference#Data, el metodo addGeoJson
    # como en https://developers.google.com/maps/documentation/javascript/3.24/reference#Data, el metodo toGeoJson
    type: object

#  GEOJsonFeatureCollection:
#    type: object
#    properties:
#      type: # types classh names swagger
#        type: string # or enum FeatureCollection | etc
#      name:
#        type: string
#      active:
#        type: boolean
#      crea_group:
#        $ref: '#/definitions/CreaGroup'
#      coneat:
#        type: integer
#      location:
#        type: object
#        properties:
#          latitude: 
#            type: number
#            format: float
#          longitude:
#            type: number
#            format: float
#      share_fucrea:
#        type: boolean
#      share_group:
#        type: boolean
#      padrons:
#        type: array
#        items:  
#          $ref: '#/definitions/Padron'
#      features:
#        type: array
#        items:  
#          type: object
#          properties:
#            type:  # types classh names swagger
#              type: string # or enum Feature | etc
#            properties: # properties classh names swagger
#              type: object
#            geometry:
#              type: object
#              items:
